local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

-- Create main window
local Window = WindUI:CreateWindow({
    Title = "PartController",
    Icon = "rbxassetid://129260712070622",
    Author = "Made By @hmmm5650",
    Transparent = true,
    Size = UDim2.fromOffset(100, 100),
    Theme = "Dark"
})

-- Create tabs
local MainTab = Window:Tab({Title = "Client"})
local RTab = Window:Tab({Title = "Ring Modfier"})
local PartManipTab = Window:Tab({Title = "Part Manipulation"}) -- New tab for advanced part manipulation
local SettingsTab = Window:Tab({Title = "Settings"})

local function AL2()

local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")
for _, v in ipairs(Lighting:GetChildren()) do
    if v:IsA("PostEffect") then
        v:Destroy()
    end
end
Lighting.GlobalShadows = false
Lighting.FogEnd = 9e9
Lighting.Brightness = 2
local function handleInstance(instance)
    if instance:IsA("BasePart") then
        local player = Players.LocalPlayer
        if player and player.Character and instance:IsDescendantOf(player.Character) then
            return
        end
        instance.Material = Enum.Material.SmoothPlastic
        instance.Reflectance = 0
    end
    if instance:IsA("Texture") or instance:IsA("Decal") then 
        local player = Players.LocalPlayer
        if player and player.Character and instance:IsDescendantOf(player.Character) then
            return
        end
        instance.Transparency = 1
    end
end
for _, instance in ipairs(workspace:GetDescendants()) do
    handleInstance(instance)
end
local terrain = workspace:FindFirstChild("Terrain")
if terrain then
    terrain.WaterWaveSize = 0
    terrain.WaterWaveSpeed = 0
    terrain.WaterReflectance = 0
    terrain.WaterTransparency = 1
end
settings().Physics.AllowSleep = true
settings().Rendering.QualityLevel = 1
settings().Rendering.EagerBulkExecution = false
settings().Rendering.TextureQuality = Enum.TextureQuality.Low

end

local function fly()
loadstring(game:HttpGet("https://raw.githubusercontent.com/OBFhm5650lol/F/refs/heads/main/F", true))()
end

local jumpPowerEnabled = false
local targetJumpPower = 50 -- Default

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local noclipConnection
local walkspeedEnabled = false
local targetWalkspeed = 16 -- default

MainTab:Button({
    Title = "AntiLag",
    Callback = function() 
        AL2()
        WindUI:Notify({
            Title = "PartController",
            Content = "Optimized!..",
            Duration = 3, -- in seconds
        })
    end
})

MainTab:Button({
    Title = "Fly",
    Callback = function() 
        fly()
        WindUI:Notify({
            Title = "PartController",
            Content = "FlyGui Loaded..",
            Duration = 3, -- in seconds
        })
    end
})

-- Walkspeed Toggle
MainTab:Toggle({
    Title = "WalkSpeed Toggle",
    Value = false,
    Callback = function(state)
        walkspeedEnabled = state
        if state and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
            LocalPlayer.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = targetWalkspeed
        elseif LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
            LocalPlayer.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = 16
        end
    end
})

-- Walkspeed Slider
MainTab:Slider({
    Title = "WalkSpeed",
    Value = {Min = 0, Max = 200, Default = 16},
    Callback = function(value)
        targetWalkspeed = value
        if walkspeedEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
            LocalPlayer.Character:FindFirstChildOfClass("Humanoid").WalkSpeed = targetWalkspeed
        end
    end
})

-- JumpPower Toggle
MainTab:Toggle({
    Title = "JumpPower Toggle",
    Value = false,
    Callback = function(state)
        jumpPowerEnabled = state
        if state and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
            local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            humanoid.UseJumpPower = true
            humanoid.JumpPower = targetJumpPower
        elseif LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
            LocalPlayer.Character:FindFirstChildOfClass("Humanoid").JumpPower = 50 -- Reset to default
        end
    end
})

-- JumpPower Slider
MainTab:Slider({
    Title = "JumpPower",
    Value = {Min = 0, Max = 200, Default = 50},
    Callback = function(value)
        targetJumpPower = value
        if jumpPowerEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
            local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            humanoid.UseJumpPower = true
            humanoid.JumpPower = targetJumpPower
        end
    end
})


-- Noclip Toggle
MainTab:Toggle({
    Title = "Noclip",
    Value = false,
    Callback = function(state)
        if state then
            noclipConnection = RunService.Stepped:Connect(function()
                local character = LocalPlayer.Character
                if character then
                    for _, part in ipairs(character:GetDescendants()) do
                        if part:IsA("BasePart") and part.CanCollide then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
        end
    end
})

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

-- Variables
local LocalPlayer = Players.LocalPlayer
local PartsFolder = Instance.new("Folder")
PartsFolder.Parent = Workspace
PartsFolder.Name = "DestroyerSystem"

-- Global handler reference for stopping
local handler = nil

-- Bypass System
local function InitializeBypass()
    local mt = getrawmetatable(game)
    setreadonly(mt, false)
    local old = mt.__namecall
    mt.__namecall = newcclosure(function(self, ...)
        local args = {...}
        local method = getnamecallmethod()
        if method == "FireServer" then
            return nil
        end
        return old(self, ...)
    end)
    
    for _, v in next, getconnections(game:GetService("ScriptContext").Error) do 
        v:Disable()
    end
    
    for _, v in next, getconnections(game:GetService("LogService").MessageOut) do 
        v:Disable()
    end
end

-- Network Ownership
local function SetupNetwork()
    settings().Physics.AllowSleep = false
    settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
    
    if not getgenv().NetworkBypass then
        getgenv().NetworkBypass = true
        local old
        old = hookmetamethod(game, "__index", newcclosure(function(self, idx)
            if idx == "NetworkOwnershipRule" then
                return Enum.NetworkOwnership.Manual
            end
            return old(self, idx)
        end))
    end
end

-- Main Destroyer System
local BasePartHandler = {}
BasePartHandler.__index = BasePartHandler

function BasePartHandler.new()
    local self = setmetatable({}, BasePartHandler)
    self.Connections = {}
    self.TargetParts = {}
    return self
end

function BasePartHandler:SetupPart(part)
    if part:IsA("BasePart") and not part.Anchored then
        if not part:IsDescendantOf(LocalPlayer.Character) then
            -- Setup part physics
            part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
            
            -- Create constraints
            local attachment = Instance.new("Attachment")
            attachment.Parent = part
            
            local alignPosition = Instance.new("AlignPosition")
            alignPosition.Mode = Enum.PositionAlignmentMode.OneAttachment
            alignPosition.Attachment0 = attachment
            alignPosition.MaxForce = 999999999999999
            alignPosition.MaxVelocity = math.huge
            alignPosition.Responsiveness = 200
            alignPosition.Parent = part
            
            local gyro = Instance.new("BodyGyro")
            gyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
            gyro.P = 100000
            gyro.Parent = part
            
            -- Add to control list
            table.insert(self.TargetParts, {
                Part = part,
                Attachment = attachment,
                AlignPosition = alignPosition,
                Gyro = gyro
            })
        end
    end
end

function BasePartHandler:Start()
    -- Setup all existing parts
    for _, v in ipairs(Workspace:GetDescendants()) do
        self:SetupPart(v)
    end
    
    -- Monitor new parts
    table.insert(self.Connections, Workspace.DescendantAdded:Connect(function(v)
        self:SetupPart(v)
    end))
    
    -- Main control loop
    table.insert(self.Connections, RunService.Heartbeat:Connect(function()
        sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
        sethiddenproperty(LocalPlayer, "MaxSimulationRadius", math.huge)
        
        for _, targetData in ipairs(self.TargetParts) do
            pcall(function()
                local part = targetData.Part
                if part and part.Parent then
                    -- Get random player as target (excluding local player)
                    local potentialTargets = {}
                    for _, player in ipairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            table.insert(potentialTargets, player)
                        end
                    end
                    
                    if #potentialTargets > 0 then
                        local randomPlayer = potentialTargets[math.random(1, #potentialTargets)]
                        local targetPos = randomPlayer.Character.HumanoidRootPart.Position
                        
                        -- Crazy movement
                        targetData.AlignPosition.Position = targetPos
                        targetData.Gyro.CFrame = CFrame.new(targetPos) * CFrame.Angles(
                            math.rad(math.random(-360, 360)),
                            math.rad(math.random(-360, 360)),
                            math.rad(math.random(-360, 360))
                        )
                        
                        -- Add force
                        part.Velocity = Vector3.new(math.random(-500, 500), math.random(-500, 500), math.random(-500, 500))
                        part.RotVelocity = Vector3.new(math.random(-500, 500), math.random(-500, 500), math.random(-500, 500))
                    end
                end
            end)
        end
    end))
end

function BasePartHandler:Stop()
    -- Disconnect all connections
    for _, connection in ipairs(self.Connections) do
        connection:Disconnect()
    end
    
    -- Clean up parts
    for _, targetData in ipairs(self.TargetParts) do
        pcall(function()
            if targetData.Part and targetData.Part.Parent then
                targetData.AlignPosition:Destroy()
                targetData.Gyro:Destroy()
                targetData.Attachment:Destroy()
                targetData.Part.CustomPhysicalProperties = nil
            end
        end)
    end
    
    -- Clear tables
    self.Connections = {}
    self.TargetParts = {}
end

-- Initialize everything
local function StartDestroyer()
    InitializeBypass()
    SetupNetwork()
    
    handler = BasePartHandler.new()
    handler:Start()
    
    -- Anti kick & crash
    spawn(function()
        while wait() do
            if LocalPlayer.Character then
                for _, connection in ipairs(getconnections(LocalPlayer.Character.DescendantAdded)) do
                    connection:Disable()
                end
            end
            game:GetService("NetworkClient"):SetOutgoingKBPSLimit(math.huge)
        end
    end)
end

-- Function to stop the destroyer
local function stopdestroyer()
    if handler then
        handler:Stop()
        handler = nil
    end
end

-- GravityInverter
local player = game.Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

-- Physics Settings
local GRAVITY_MULTIPLIER = 1.5 -- Visible but not too fast
local INITIAL_BOOST = 10 -- Gentle push to start
local MAX_SPEED = 20 -- Maximum upward speed
local SIMULATION_RADIUS = 5000 -- Large area of effect

-- System Variables
local invertedParts = {}
local connection = nil
local heartbeatConnection = nil

local function cleanUpForces(part)
    for _, child in ipairs(part:GetChildren()) do
        if child:IsA("BodyForce") or child:IsA("BodyVelocity") then
            child:Destroy()
        end
    end
end

local function applyUpwardForce()
    -- Ensure we can affect distant parts
    sethiddenproperty(player, "SimulationRadius", SIMULATION_RADIUS)
    sethiddenproperty(player, "MaxSimulationRadius", SIMULATION_RADIUS)
    
    for part, data in pairs(invertedParts) do
        if part and part.Parent then
            -- Calculate upward force based on part's mass
            local force = part:GetMass() * Workspace.Gravity * GRAVITY_MULTIPLIER
            
            -- Apply force while respecting max speed
            if part.Velocity.Y < MAX_SPEED then
                part:ApplyImpulse(Vector3.new(0, force * 0.016, 0)) -- 0.016 ≈ 1/60 for frame independence
            end
            
            -- Ensure parts don't get stuck
            if part.Velocity.Y < 5 then
                part.Velocity = Vector3.new(0, 5, 0)
            end
        else
            invertedParts[part] = nil
        end
    end
end

local function invertGravity(part)
    if part:IsA("BasePart") and not part.Anchored and not part:IsDescendantOf(player.Character) then
        if not invertedParts[part] then
            -- Store original state
            invertedParts[part] = {
                CanCollide = part.CanCollide,
                CustomPhysicalProperties = part.CustomPhysicalProperties
            }
            
            -- Clean existing forces
            cleanUpForces(part)
            
            -- Configure part physics
            part.CanCollide = false
            part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
            
            -- Initial gentle push
            part.Velocity = Vector3.new(0, INITIAL_BOOST, 0)
            
            -- Add permanent upward force
            local bodyForce = Instance.new("BodyForce")
            bodyForce.Force = Vector3.new(0, part:GetMass() * Workspace.Gravity * GRAVITY_MULTIPLIER, 0)
            bodyForce.Parent = part
            invertedParts[part].bodyForce = bodyForce
        end
    end
end

local function restoreGravity(part)
    if invertedParts[part] then
        cleanUpForces(part)
        part.CanCollide = invertedParts[part].CanCollide
        part.CustomPhysicalProperties = invertedParts[part].CustomPhysicalProperties
        part.Velocity = Vector3.new(0, 0, 0)
        invertedParts[part] = nil
    end
end

function GravOn()
    -- Set physics range
    sethiddenproperty(player, "SimulationRadius", SIMULATION_RADIUS)
    
    -- Process existing parts
    for _, part in ipairs(Workspace:GetDescendants()) do
        invertGravity(part)
    end
    
    -- Continuous force application
    if heartbeatConnection then heartbeatConnection:Disconnect() end
    heartbeatConnection = RunService.Heartbeat:Connect(applyUpwardForce)
    
    -- Detect new parts
    if connection then connection:Disconnect() end
    connection = Workspace.DescendantAdded:Connect(invertGravity)
end

function GravOff()
    -- Clean up
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
    
    for part in pairs(invertedParts) do
        if part.Parent then
            restoreGravity(part)
        end
    end
    
    invertedParts = {}
    if connection then
        connection:Disconnect()
        connection = nil
    end
end

-- Network Ownership
local function SetupNetwork()
    settings().Physics.AllowSleep = false
    settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
    
    if not getgenv().NetworkBypass then
        getgenv().NetworkBypass = true
        local old
        old = hookmetamethod(game, "__index", newcclosure(function(self, idx)
            if idx == "NetworkOwnershipRule" then
                return Enum.NetworkOwnership.Manual
            end
            return old(self, idx)
        end))
    end
end

local function blackHoleScript()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer
    local Workspace = game:GetService("Workspace")

    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    Folder = Instance.new("Folder", Workspace)
    local Part = Instance.new("Part", Folder)
    Attachment1 = Instance.new("Attachment", Part)
    Part.Anchored = true
    Part.CanCollide = false
    Part.Transparency = 1

    if not Network then
        Network = {
            BaseParts = {},
            Velocity = Vector3.new(14.46262424, 14.46262424, 14.46262424)
        }

        Network.RetainPart = function(Part)
            if typeof(Part) == "Instance" and Part:IsA("BasePart") and Part:IsDescendantOf(Workspace) then
                table.insert(Network.BaseParts, Part)
                Part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
                Part.CanCollide = false
            end
        end

        local function EnablePartControl()
            LocalPlayer.ReplicationFocus = Workspace
            RunService.Heartbeat:Connect(function()
                sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
                for _, Part in pairs(Network.BaseParts) do
                    if Part:IsDescendantOf(Workspace) then
                        Part.Velocity = Network.Velocity
                    end
                end
            end)
        end

        EnablePartControl()
    end

    local function ForcePart(v)
        if v:IsA("Part") and not v.Anchored and not v.Parent:FindFirstChild("Humanoid") and not v.Parent:FindFirstChild("Head") and v.Name ~= "Handle" then
            for _, x in next, v:GetChildren() do
                if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro") or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity") or x:IsA("RocketPropulsion") then
                    x:Destroy()
                end
            end
            if v:FindFirstChild("Attachment") then
                v:FindFirstChild("Attachment"):Destroy()
            end
            if v:FindFirstChild("AlignPosition") then
                v:FindFirstChild("AlignPosition"):Destroy()
            end
            if v:FindFirstChild("Torque") then
                v:FindFirstChild("Torque"):Destroy()
            end
            v.CanCollide = false
            local Torque = Instance.new("Torque", v)
            Torque.Torque = Vector3.new(100000, 100000, 100000)
            local AlignPosition = Instance.new("AlignPosition", v)
            local Attachment2 = Instance.new("Attachment", v)
            Torque.Attachment0 = Attachment2
            AlignPosition.MaxForce = 9999999999999999
            AlignPosition.MaxVelocity = math.huge
            AlignPosition.Responsiveness = 200
            AlignPosition.Attachment0 = Attachment2
            AlignPosition.Attachment1 = Attachment1
        end
    end

    blackHoleActive = true

    for _, v in next, Workspace:GetDescendants() do
        ForcePart(v)
    end

    Workspace.DescendantAdded:Connect(function(v)
        if blackHoleActive then
            ForcePart(v)
        end
    end)

    spawn(function()
        while blackHoleActive and RunService.RenderStepped:Wait() do
            Attachment1.WorldCFrame = humanoidRootPart.CFrame
        end
    end)
end

-- Function to disable black hole
local function disableBlackHole()
    blackHoleActive = false
    if Folder then
        Folder:Destroy()
        Folder = nil
    end
    if Network then
        Network.BaseParts = {}
    end
end

-- Define modes table
local modes = {
    "Vertical Ring",
    "Horizontal Ring", 
    "Vertical & Horizontal",
    "Left Tilt",
    "Right Tilt",
    "Left & Right Tilt",
    "Spiral",
    "Figure 8",
    "DNA Helix",
    "Flower Pattern",
    "Galaxy Spiral",
    "Infinity",
    "Wave Pattern",
    "Atomic Orbit",
    "Butterfly",
    "Tornado",
    "Heart",
    "Vortex",
    "Pendulum",
    "Lemniscate 3D",
    "Star Pattern",
    "Trefoil Knot",
    "Double Spiral",
    "Mobius Strip",
    "Hypocycloid",
    "Sphere Spiral",
    "Asteroid Belt",
    "Rose Curve",
    "Lissajous",
    "Polygonal Orbit"
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

-- Define variables
local ringParts = {}
local radius = 50
local speed = 2
local isActive = false
local lastValidPosition = Vector3.new(0, 0, 0)
local UPDATE_INTERVAL = 0
local lastUpdate = tick()
local currentMode = 2

-- Network System
if not getgenv().Network then
    getgenv().Network = {
        BaseParts = {},
        FPS = 30,
        Velocity = Vector3.new(25.1, 0, 0)
    }
    
    local function EnableNetwork()
        local function UpdateNetwork()
            if not isActive then return end
            
            -- First update player simulation radius
            pcall(function()
                sethiddenproperty(LocalPlayer, "MaxSimulationRadius", math.huge)
                sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
            end)
            
            -- Create a list of parts to process first to avoid modification during iteration
            local partsToProcess = {}
            for part in pairs(Network.BaseParts) do
                table.insert(partsToProcess, part)
            end
            
            -- Process each part with error handling
            for _, part in ipairs(partsToProcess) do
                if not part or not part.Parent then
                    Network.BaseParts[part] = nil
                    continue
                end
                
                pcall(function()
                    sethiddenproperty(part, "NetworkOwnership", Enum.NetworkOwnership.Manual)
                    sethiddenproperty(part, "CustomPhysicalProperties", PhysicalProperties.new(0.7, 0.3, 0.5))
                    part.Velocity = Network.Velocity
                end)
            end
        end
        
        RunService.Heartbeat:Connect(UpdateNetwork)
    end
    
    EnableNetwork()
end

-- Player Setup Function
local function setupPlayer()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    lastValidPosition = humanoidRootPart.Position
    return humanoidRootPart
end

local humanoidRootPart = setupPlayer()

-- Optimized Part Processing
local function processPart(part)
    if part:IsA("Part") and not part.Anchored and 
       not part.Parent:FindFirstChild("Humanoid") and 
       not part.Parent:FindFirstChild("Head") and 
       part.Name ~= "Handle" then
        
        -- Check if part still exists
        if not pcall(function() return part.Parent end) then
            return nil
        end
        
        -- Remove unwanted children
        for _, child in pairs(part:GetChildren()) do
            if child:IsA("BodyAngularVelocity") or 
               child:IsA("BodyForce") or 
               child:IsA("BodyGyro") or 
               child:IsA("BodyPosition") or 
               child:IsA("BodyThrust") or 
               child:IsA("BodyVelocity") or 
               child:IsA("RocketPropulsion") or 
               child:IsA("Attachment") or 
               child:IsA("AlignPosition") or 
               child:IsA("AlignOrientation") or 
               child:IsA("LinearVelocity") or 
               child:IsA("Torque") or 
               child:IsA("BodyCenterOfMass") or 
               child:IsA("BodyMover") or 
               child:IsA("BodyMover2") or 
               child:IsA("BallSocketConstraint") or 
               child:IsA("WeldConstraint") or
               child:IsA("RodConstraint") or 
               child:IsA("SpringConstraint") or 
               child:IsA("Motor6D") or
               child:IsA("VectorForce") or
               child:IsA("LineForce") or
               child:IsA("HingeConstraint") or
               child:IsA("CylindricalConstraint") or
               child:IsA("PrismaticConstraint") or 
               child:IsA("PlaneConstraint") or 
               child:IsA("SlidingBallConstraint") then
                child:Destroy()
            end
        end
        
        part.CanCollide = false
        part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
        
        local attachment = Instance.new("Attachment", part)
        
        local alignPos = Instance.new("AlignPosition", part)
        alignPos.Attachment0 = attachment
        alignPos.Mode = Enum.PositionAlignmentMode.OneAttachment
        alignPos.Responsiveness = 200
        
        return {
            part = part,
            align = alignPos,
            index = 0
        }
    end
    return nil
end

-- Calculate Ring Position with Multiple Modes
local function calculateRingPosition(index, totalParts, center)
    local angle = (index / totalParts) * (2 * math.pi) + tick() * speed
    local offsetX, offsetY, offsetZ = 0, 0, 0
    
    if currentMode == 1 then  -- Vertical Ring
        offsetX = math.cos(angle) * radius
        offsetY = math.sin(angle) * radius
    elseif currentMode == 2 then  -- Horizontal Ring
        offsetX = math.cos(angle) * radius
        offsetZ = math.sin(angle) * radius
    elseif currentMode == 3 then  -- Vertical & Horizontal
        local angle2 = angle + math.pi/2
        offsetX = math.cos(angle) * radius
        offsetY = math.sin(angle2) * radius
        offsetZ = math.sin(angle) * radius
    elseif currentMode == 4 then  -- Left Tilt
        offsetX = math.cos(angle) * radius
        offsetY = math.sin(angle) * radius * 0.5
        offsetZ = math.sin(angle) * radius * 0.866
    elseif currentMode == 5 then  -- Right Tilt
        offsetX = math.cos(angle) * radius
        offsetY = math.sin(angle) * radius * 0.5
        offsetZ = -math.sin(angle) * radius * 0.866
    elseif currentMode == 6 then  -- Left & Right Tilt
        local tiltAngle = math.sin(tick() * speed * 0.5) * math.pi/3
        offsetX = math.cos(angle) * radius
        offsetY = math.sin(angle) * radius * math.cos(tiltAngle)
        offsetZ = math.sin(angle) * radius * math.sin(tiltAngle)
    elseif currentMode == 7 then  -- Spiral
        local heightOffset = ((index / totalParts) * 2 - 1) * radius
        offsetX = math.cos(angle) * radius
        offsetY = heightOffset
        offsetZ = math.sin(angle) * radius
    elseif currentMode == 8 then  -- Figure 8
        local scale = 1.5
        offsetX = math.cos(angle) * radius
        offsetY = math.sin(2 * angle) * radius * 0.5
        offsetZ = math.sin(angle) * radius * scale
    elseif currentMode == 9 then  -- DNA Helix
        local heightOffset = math.sin(tick() * speed) * radius
        offsetX = math.cos(angle) * radius
        offsetY = math.cos(angle * 2) * radius + heightOffset
        offsetZ = math.sin(angle) * radius
    elseif currentMode == 10 then  -- Flower Pattern
        local petalCount = 5
        local r = math.cos(petalCount * angle) * radius
        offsetX = math.cos(angle) * r
        offsetY = math.sin(angle) * r
        offsetZ = math.sin(petalCount * angle) * radius * 0.5
    elseif currentMode == 11 then  -- Galaxy Spiral
        local spiralTightness = 0.2
        local r = (1 + angle * spiralTightness) * radius
        offsetX = math.cos(angle) * r
        offsetY = math.sin(tick() * speed) * radius * 0.2
        offsetZ = math.sin(angle) * r
    elseif currentMode == 12 then  -- Infinity
        local scale = 1.5
        offsetX = math.cos(angle) * radius * scale
        offsetY = math.sin(2 * angle) * radius * 0.5
        offsetZ = math.sin(angle) * radius
    elseif currentMode == 13 then  -- Wave Pattern
        offsetX = angle * radius * 0.1
        offsetY = math.sin(angle * 2) * radius
        offsetZ = math.cos(angle * 2) * radius
    elseif currentMode == 14 then  -- Atomic Orbit
        local subOrbitRadius = radius * 0.3
        local mainAngle = tick() * speed
        local subAngle = angle * 3
        offsetX = math.cos(mainAngle) * radius + math.cos(subAngle) * subOrbitRadius
        offsetY = math.sin(mainAngle) * radius + math.sin(subAngle) * subOrbitRadius
        offsetZ = math.cos(subAngle) * subOrbitRadius
    elseif currentMode == 15 then  -- Butterfly
        local t = angle
        offsetX = math.sin(t) * (math.exp(math.cos(t)) - 2 * math.cos(4*t) - math.pow(math.sin(t/12), 5)) * radius * 0.5
        offsetY = math.cos(t) * (math.exp(math.cos(t)) - 2 * math.cos(4*t) - math.pow(math.sin(t/12), 5)) * radius * 0.5
        offsetZ = math.sin(t * 3) * radius * 0.3
    elseif currentMode == 16 then -- Tornado
        local heightScale = 2
        local r = radius * (1 - (index / totalParts))
        offsetX = math.cos(angle) * r
        offsetY = (index / totalParts) * radius * heightScale
        offsetZ = math.sin(angle) * r
    elseif currentMode == 17 then -- Heart
        local t = angle
        offsetX = 16 * math.sin(t) ^ 3 * (radius * 0.1)
        offsetY = (13 * math.cos(t) - 5 * math.cos(2*t) - 2 * math.cos(3*t) - math.cos(4*t)) * (radius * 0.1)
        offsetZ = math.sin(t * 2) * radius * 0.3
    elseif currentMode == 18 then -- Vortex
        local spiral = angle * 0.1
        local height = math.sin(tick() * speed) * radius
        offsetX = (radius + spiral) * math.cos(angle)
        offsetY = height + (index / totalParts) * radius
        offsetZ = (radius + spiral) * math.sin(angle)
    elseif currentMode == 19 then -- Pendulum
        local swingAngle = math.sin(tick() * speed) * math.pi/2
        offsetX = math.sin(swingAngle) * radius
        offsetY = -math.cos(swingAngle) * radius
        offsetZ = math.sin(angle) * radius * 0.3
    elseif currentMode == 20 then -- Lemniscate 3D
        local t = angle
        local scale = radius * 0.8
        offsetX = scale * math.cos(t) / (1 + math.sin(t)^2)
        offsetY = scale * math.sin(t) * math.cos(t) / (1 + math.sin(t)^2)
        offsetZ = math.sin(t * 2) * radius * 0.5
    elseif currentMode == 21 then -- Star Pattern
        local points = 5
        local innerRadius = radius * 0.4
        local t = angle * points
        local r = innerRadius + (radius - innerRadius) * math.abs(math.sin(t))
        offsetX = r * math.cos(angle)
        offsetY = r * math.sin(angle)
        offsetZ = math.sin(angle * points) * radius * 0.3
    elseif currentMode == 22 then -- Trefoil Knot
        local t = angle
        offsetX = (2 + math.cos(3*t)) * math.cos(2*t) * radius * 0.2
        offsetY = (2 + math.cos(3*t)) * math.sin(2*t) * radius * 0.2
        offsetZ = math.sin(3*t) * radius * 0.2
    elseif currentMode == 23 then -- Double Spiral
        local t = angle
        local r1 = radius * (0.5 + 0.5 * math.cos(t * 5))
        local r2 = radius * (0.5 + 0.5 * math.sin(t * 5))
        offsetX = math.cos(t) * r1
        offsetY = math.sin(t) * r1
        offsetZ = math.cos(t) * r2
    elseif currentMode == 24 then -- Mobius Strip
        local t = angle
        local s = (index / totalParts) * 2 - 1
        offsetX = (radius + s * math.cos(t/2)) * math.cos(t)
        offsetY = (radius + s * math.cos(t/2)) * math.sin(t)
        offsetZ = s * math.sin(t/2)
    elseif currentMode == 25 then -- Hypocycloid
        local a = radius
        local b = radius * 0.2
        local t = angle * 4
        offsetX = (a - b) * math.cos(t) + b * math.cos((a-b)/b * t)
        offsetY = (a - b) * math.sin(t) - b * math.sin((a-b)/b * t)
        offsetZ = math.sin(t * 2) * radius * 0.3
    elseif currentMode == 26 then -- Sphere Spiral
        local phi = angle
        local theta = (index / totalParts) * math.pi
        offsetX = radius * math.sin(theta) * math.cos(phi)
        offsetY = radius * math.sin(theta) * math.sin(phi)
        offsetZ = radius * math.cos(theta)
    elseif currentMode == 27 then -- Asteroid Belt
        local baseAngle = (index / totalParts) * (2 * math.pi)
        local wobble = math.sin(tick() * speed + baseAngle * 3) * (radius * 0.2)
        local r = radius + wobble
        offsetX = math.cos(angle) * r
        offsetY = math.sin(baseAngle * 2) * (radius * 0.1)
        offsetZ = math.sin(angle) * r
    elseif currentMode == 28 then -- Rose Curve
        local n = 3 -- number of petals
        local d = 2
        local k = n/d
        local r = radius * math.cos(k * angle)
        offsetX = r * math.cos(angle)
        offsetY = r * math.sin(angle)
        offsetZ = math.sin(angle * k) * radius * 0.3
    elseif currentMode == 29 then -- Lissajous
        local a = 3
        local b = 2
        offsetX = radius * math.sin(a * angle)
        offsetY = radius * math.cos(b * angle)
        offsetZ = radius * math.sin((a+b) * angle) * 0.3
    elseif currentMode == 30 then -- Polygonal Orbit
        local sides = 6
        local angleSnap = math.floor(angle * sides / (2 * math.pi)) * (2 * math.pi / sides)
        local transition = (angle * sides / (2 * math.pi)) % 1
        local nextAngleSnap = angleSnap + (2 * math.pi / sides)
        
        local currentX = math.cos(angleSnap) * radius
        local currentZ = math.sin(angleSnap) * radius
        local nextX = math.cos(nextAngleSnap) * radius
        local nextZ = math.sin(nextAngleSnap) * radius
        
        offsetX = currentX + (nextX - currentX) * transition
        offsetY = math.sin(angle * 2) * radius * 0.2
        offsetZ = currentZ + (nextZ - currentZ) * transition
    end
    
    return center + Vector3.new(offsetX, offsetY, offsetZ)
end

-- Update Ring Positions
local function updateRingPositions()
    if not isActive then return end
    
    local currentTime = tick()
    if currentTime - lastUpdate < UPDATE_INTERVAL then return end
    lastUpdate = currentTime
    
    local position = (humanoidRootPart and humanoidRootPart.Position) or lastValidPosition
    if position then
        lastValidPosition = position
        local totalParts = #ringParts
        
        for i = #ringParts, 1, -1 do
            local data = ringParts[i]
            local validPart = pcall(function() return data.part.Parent ~= nil end)
            if validPart then
                local targetPos = calculateRingPosition(i, totalParts, position)
                data.align.Position = targetPos
            else
                Network.BaseParts[data.part] = nil
                table.remove(ringParts, i)
            end
        end
    end
end

-- Main Ring Control
local function toggleRing()
    isActive = not isActive
    
    if isActive then
        ringParts = {}
        for _, v in ipairs(Workspace:GetDescendants()) do
            local partData = processPart(v)
            if partData then
                table.insert(ringParts, partData)
                Network.BaseParts[partData.part] = true
            end
        end
        
        local connection
        connection = Workspace.DescendantAdded:Connect(function(v)
            if not isActive then
                connection:Disconnect()
                return
            end
            local partData = processPart(v)
            if partData then
                table.insert(ringParts, partData)
                Network.BaseParts[partData.part] = true
            end
        end)
        
        RunService.Heartbeat:Connect(updateRingPositions)
    else
        for i = #ringParts, 1, -1 do
            local data = ringParts[i]
            if data.part and data.part.Parent then
                Network.BaseParts[data.part] = nil
                if data.align then 
                    pcall(function() data.align:Destroy() end)
                end
            end
        end
        ringParts = {}
    end
end

local function r()

pcall(function()

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CollectionService = game:GetService("CollectionService")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- Create the invisible part for attachments
local Folder = Instance.new("Folder", Workspace)
local Part = Instance.new("Part", Folder)
local Attachment1 = Instance.new("Attachment", Part)
Part.Anchored = true
Part.CanCollide = false
Part.Transparency = 1

-- GUI Implementation
local G2L = {}

-- Create ScreenGui
G2L["ScreenGui_1"] = Instance.new("ScreenGui", game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"))
G2L["ScreenGui_1"]["ZIndexBehavior"] = Enum.ZIndexBehavior.Sibling

-- Tags
CollectionService:AddTag(G2L["ScreenGui_1"], "main")

-- Main Frame
G2L["Frame_2"] = Instance.new("Frame", G2L["ScreenGui_1"])
G2L["Frame_2"]["BorderSizePixel"] = 0
G2L["Frame_2"]["BackgroundColor3"] = Color3.fromRGB(41, 41, 41)
G2L["Frame_2"]["Size"] = UDim2.new(0, 130, 0, 148)
G2L["Frame_2"]["Position"] = UDim2.new(0, 310, 0, 60)
G2L["Frame_2"]["BackgroundTransparency"] = 0.2

-- Radius TextBox
G2L["RaidusTextBox_3"] = Instance.new("TextBox", G2L["Frame_2"])
G2L["RaidusTextBox_3"]["CursorPosition"] = -1
G2L["RaidusTextBox_3"]["Name"] = "RaidusTextBox"
G2L["RaidusTextBox_3"]["BorderSizePixel"] = 0
G2L["RaidusTextBox_3"]["TextColor3"] = Color3.fromRGB(255, 255, 255)
G2L["RaidusTextBox_3"]["BackgroundColor3"] = Color3.fromRGB(41, 41, 41)
G2L["RaidusTextBox_3"]["PlaceholderText"] = "Radius"
G2L["RaidusTextBox_3"]["Size"] = UDim2.new(0, 100, 0, 20)
G2L["RaidusTextBox_3"]["Position"] = UDim2.new(0, 16, 0, 62)
G2L["RaidusTextBox_3"]["Text"] = "70"

-- Radius TextBox Corner
G2L["UICorner_4"] = Instance.new("UICorner", G2L["RaidusTextBox_3"])

-- Main Frame Corner
G2L["UICorner_5"] = Instance.new("UICorner", G2L["Frame_2"])

-- Frame for minimize button
G2L["Frame2_6"] = Instance.new("Frame", G2L["Frame_2"])
G2L["Frame2_6"]["BorderSizePixel"] = 0
G2L["Frame2_6"]["BackgroundColor3"] = Color3.fromRGB(41, 41, 41)
G2L["Frame2_6"]["Size"] = UDim2.new(0, 130, 0, 20)
G2L["Frame2_6"]["Name"] = "Frame2"

-- Frame2 Corner
G2L["UICorner_7"] = Instance.new("UICorner", G2L["Frame2_6"])

-- Minimize Button
G2L["MinimiseBtn_8"] = Instance.new("TextButton", G2L["Frame2_6"])
G2L["MinimiseBtn_8"]["BorderSizePixel"] = 0
G2L["MinimiseBtn_8"]["TextSize"] = 11
G2L["MinimiseBtn_8"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255)
G2L["MinimiseBtn_8"]["BackgroundTransparency"] = 1
G2L["MinimiseBtn_8"]["Size"] = UDim2.new(0, 32, 0, 18)
G2L["MinimiseBtn_8"]["Text"] = "➖"
G2L["MinimiseBtn_8"]["Name"] = "MinimiseBtn"
G2L["MinimiseBtn_8"]["Position"] = UDim2.new(0, 98, 0, 0)

-- Attraction Strength TextBox
G2L["ASTextBox_9"] = Instance.new("TextBox", G2L["Frame_2"])
G2L["ASTextBox_9"]["CursorPosition"] = -1
G2L["ASTextBox_9"]["Name"] = "ASTextBox"
G2L["ASTextBox_9"]["BorderSizePixel"] = 0
G2L["ASTextBox_9"]["TextColor3"] = Color3.fromRGB(255, 255, 255)
G2L["ASTextBox_9"]["BackgroundColor3"] = Color3.fromRGB(41, 41, 41)
G2L["ASTextBox_9"]["PlaceholderText"] = "Speed"
G2L["ASTextBox_9"]["Size"] = UDim2.new(0, 100, 0, 20)
G2L["ASTextBox_9"]["Position"] = UDim2.new(0, 16, 0, 86)
G2L["ASTextBox_9"]["Text"] = "555"

-- AS TextBox Corner
G2L["UICorner_a"] = Instance.new("UICorner", G2L["ASTextBox_9"])

-- Toggle Button
G2L["Toggle_b"] = Instance.new("TextButton", G2L["Frame_2"])
G2L["Toggle_b"]["BorderSizePixel"] = 0
G2L["Toggle_b"]["TextColor3"] = Color3.fromRGB(255, 255, 255)
G2L["Toggle_b"]["BackgroundColor3"] = Color3.fromRGB(41, 41, 41)
G2L["Toggle_b"]["Size"] = UDim2.new(0, 104, 0, 24)
G2L["Toggle_b"]["Text"] = "Ringparts: OFF"
G2L["Toggle_b"]["Name"] = "Toggle"
G2L["Toggle_b"]["Position"] = UDim2.new(0, 14, 0, 30)

-- Toggle Button Corner
G2L["UICorner_c"] = Instance.new("UICorner", G2L["Toggle_b"])

-- Title
G2L["Title_d"] = Instance.new("TextLabel", G2L["Frame_2"])
G2L["Title_d"]["BorderSizePixel"] = 0
G2L["Title_d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255)
G2L["Title_d"]["TextColor3"] = Color3.fromRGB(255, 255, 255)
G2L["Title_d"]["BackgroundTransparency"] = 1
G2L["Title_d"]["Size"] = UDim2.new(0, 88, 0, 12)
G2L["Title_d"]["Text"] = "RingParts"
G2L["Title_d"]["Name"] = "Title"
G2L["Title_d"]["Position"] = UDim2.new(0, 20, 0, 4)

-- UI Stroke
G2L["UIStroke_e"] = Instance.new("UIStroke", G2L["Frame_2"])
G2L["UIStroke_e"]["Transparency"] = 0.1
G2L["UIStroke_e"]["Thickness"] = 3
G2L["UIStroke_e"]["Color"] = Color3.fromRGB(41, 41, 41)

-- SuperRing functionality
local radius = tonumber(G2L["RaidusTextBox_3"].Text) or 70
local height = 100
local rotationSpeed = 0.5
local attractionStrength = tonumber(G2L["ASTextBox_9"].Text) or 555
local ringPartsEnabled = false

-- Network part control
if not getgenv().Network then
    getgenv().Network = {
        BaseParts = {},
        Velocity = Vector3.new(14.46262424, 14.46262424, 14.46262424)
    }

    Network.RetainPart = function(Part)
        if typeof(Part) == "Instance" and Part:IsA("BasePart") and Part:IsDescendantOf(Workspace) then
            table.insert(Network.BaseParts, Part)
            Part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
            Part.CanCollide = false
        end
    end

    local function EnablePartControl()
        LocalPlayer.ReplicationFocus = Workspace
        RunService.Heartbeat:Connect(function()
            sethiddenproperty(LocalPlayer, "SimulationRadius", math.huge)
            for _, Part in pairs(Network.BaseParts) do
                if Part:IsDescendantOf(Workspace) then
                    Part.Velocity = Network.Velocity
                end
            end
        end)
    end

    EnablePartControl()
end

local function ForcePart(v)
    if v:IsA("Part") and not v.Anchored and not v.Parent:FindFirstChild("Humanoid") and not v.Parent:FindFirstChild("Head") and v.Name ~= "Handle" then
        for _, x in next, v:GetChildren() do
            if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro") or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity") or x:IsA("RocketPropulsion") then
                x:Destroy()
            end
        end
        if v:FindFirstChild("Attachment") then
            v:FindFirstChild("Attachment"):Destroy()
        end
        if v:FindFirstChild("AlignPosition") then
            v:FindFirstChild("AlignPosition"):Destroy()
        end
        if v:FindFirstChild("Torque") then
            v:FindFirstChild("Torque"):Destroy()
        end
        v.CanCollide = false
        local Torque = Instance.new("Torque", v)
        Torque.Torque = Vector3.new(100000, 100000, 100000)
        local AlignPosition = Instance.new("AlignPosition", v)
        local Attachment2 = Instance.new("Attachment", v)
        Torque.Attachment0 = Attachment2
        AlignPosition.MaxForce = 9999999999999999
        AlignPosition.MaxVelocity = math.huge
        AlignPosition.Responsiveness = 200
        AlignPosition.Attachment0 = Attachment2
        AlignPosition.Attachment1 = Attachment1
    end
end

local function RetainPart(Part)
    if Part:IsA("BasePart") and not Part.Anchored and Part:IsDescendantOf(workspace) then
        if Part.Parent == LocalPlayer.Character or Part:IsDescendantOf(LocalPlayer.Character) then
            return false
        end

        Part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
        Part.CanCollide = false
        return true
    end
    return false
end

local parts = {}
local function addPart(part)
    if RetainPart(part) then
        if not table.find(parts, part) then
            table.insert(parts, part)
        end
    end
end

local function removePart(part)
    local index = table.find(parts, part)
    if index then
        table.remove(parts, index)
    end
end

for _, part in pairs(workspace:GetDescendants()) do
    addPart(part)
end

workspace.DescendantAdded:Connect(addPart)
workspace.DescendantRemoving:Connect(removePart)

RunService.Heartbeat:Connect(function()
    if not ringPartsEnabled then return end
    
    local humanoidRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        local tornadoCenter = humanoidRootPart.Position
        for _, part in pairs(parts) do
            if part.Parent and not part.Anchored then
                local pos = part.Position
                local distance = (Vector3.new(pos.X, tornadoCenter.Y, pos.Z) - tornadoCenter).Magnitude
                local angle = math.atan2(pos.Z - tornadoCenter.Z, pos.X - tornadoCenter.X)
                local newAngle = angle + math.rad(rotationSpeed)
                local targetPos = Vector3.new(
                    tornadoCenter.X + math.cos(newAngle) * math.min(radius, distance),
                    tornadoCenter.Y + (height * (math.abs(math.sin((pos.Y - tornadoCenter.Y) / height)))),
                    tornadoCenter.Z + math.sin(newAngle) * math.min(radius, distance)
                )
                local directionToTarget = (targetPos - part.Position).unit
                part.Velocity = directionToTarget * attractionStrength
            end
        end
    end
end)

-- Button functionality
G2L["Toggle_b"].MouseButton1Click:Connect(function()
    ringPartsEnabled = not ringPartsEnabled
    G2L["Toggle_b"].Text = ringPartsEnabled and "Ringparts: ON" or "Ringparts: OFF"
end)

-- Update radius when text changes
G2L["RaidusTextBox_3"].FocusLost:Connect(function(enterPressed)
    if enterPressed then
        local newRadius = tonumber(G2L["RaidusTextBox_3"].Text)
        if newRadius then
            radius = math.clamp(newRadius, 1, 1000)
            G2L["RaidusTextBox_3"].Text = tostring(radius)
        else
            G2L["RaidusTextBox_3"].Text = tostring(radius)
        end
    end
end)

-- Update attraction strength when text changes
G2L["ASTextBox_9"].FocusLost:Connect(function(enterPressed)
    if enterPressed then
        local newStrength = tonumber(G2L["ASTextBox_9"].Text)
        if newStrength then
            attractionStrength = math.clamp(newStrength, 1, 10000)
            G2L["ASTextBox_9"].Text = tostring(attractionStrength)
        else
            G2L["ASTextBox_9"].Text = tostring(attractionStrength)
        end
    end
end)

-- Make GUI draggable
local dragging
local dragInput
local dragStart
local startPos

local function update(input)
    local delta = input.Position - dragStart
    G2L["Frame_2"].Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

G2L["Frame_2"].InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = G2L["Frame_2"].Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

G2L["Frame_2"].InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

-- Minimize functionality
local minimized = false
G2L["MinimiseBtn_8"].MouseButton1Click:Connect(function()
    minimized = not minimized
    if minimized then
        G2L["Frame_2"].Size = UDim2.new(0, 130, 0, 20)
        G2L["Toggle_b"].Visible = false
        G2L["RaidusTextBox_3"].Visible = false
        G2L["ASTextBox_9"].Visible = false
        G2L["MinimiseBtn_8"].Text = "➕"
    else
        G2L["Frame_2"].Size = UDim2.new(0, 130, 0, 148)
        G2L["Toggle_b"].Visible = true
        G2L["RaidusTextBox_3"].Visible = true
        G2L["ASTextBox_9"].Visible = true
        G2L["MinimiseBtn_8"].Text = "➖"
    end
end)

end)

end

-- Add elements to Main Tab
RTab:Button({
    Title = "Toggle Ring",
    Callback = function() 
        toggleRing()
        WindUI:Notify({
            Title = "PartController",
            Content = isActive and "Ring started!" or "Ring stopped!"
        })
    end
})

RTab:Button({
    Title = "RingPartsGui [Less Laggy]",
    Callback = function() 
        r()
        WindUI:Notify({
            Title = "PartController",
            Content = "Opened RingParts Gui",
            Duration = 5, -- in seconds
        })
    end
})

RTab:Dropdown({
    Title = "Orbit Mode",
    Values = modes,
    Callback = function(mode)
        currentMode = table.find(modes, mode)
    end
})

RTab:Slider({
    Title = "Radius",
    Value = {Min = 1, Max = 100, Default = 50},
    Callback = function(value)
        radius = value
    end
})

RTab:Slider({
    Title = "Speed",
    Value = {Min = 0.1, Max = 10, Default = 2},
    Callback = function(value)
        speed = value
    end
})

-- Add elements to Settings Tab
SettingsTab:Dropdown({
    Title = "Select Theme",
    Values = {"Dark", "Light", "Amber", "Sky", "Indigo"},
    Callback = function(theme)
        WindUI:SetTheme(theme)
    end
})

SettingsTab:Toggle({
    Title = "Toggle Window Transparency",
    Callback = function(e)
        Window:ToggleTransparency(e)
    end,
    Value = WindUI:GetTransparency()
})

-- Character added event
LocalPlayer.CharacterAdded:Connect(function()
    humanoidRootPart = setupPlayer()
    if isActive then
        toggleRing()
        task.wait()
        toggleRing()
    end
end)


PartManipTab:Button({
    Title = "Enable BlackHole",
    Callback = function() 
        blackHoleScript()
        WindUI:Notify({
            Title = "PartController",
            Content = "Blackhole is Enabled",
            Duration = 5, -- in seconds
        })
    end
})

PartManipTab:Button({
    Title = "Disable BlackHole",
    Callback = function() 
        disableBlackHole()
        WindUI:Notify({
            Title = "PartController",
            Content = "Blackhole is Disabled ",
            Duration = 5, -- in seconds
        })
    end
})

PartManipTab:Button({
    Title = "Enable InvertGravity",
    Callback = function() 
        GravOn()
        WindUI:Notify({
            Title = "PartController",
            Content = "InvertGravity is Enabled",
            Duration = 5, -- in seconds
        })
    end
})

PartManipTab:Button({
    Title = "Disable InvertGravity",
    Callback = function() 
        GravOff()
        WindUI:Notify({
            Title = "PartController",
            Content = "InvertGravity is Disabled ",
            Duration = 5, -- in seconds
        })
    end
})

PartManipTab:Button({
    Title = "Enable Tpua",
    Callback = function() 
        StartDestroyer()
        WindUI:Notify({
            Title = "PartController",
            Content = "Tpua is Enabled",
            Duration = 5, -- in seconds
        })
    end
})

PartManipTab:Button({
    Title = "Disable Tpua",
    Callback = function() 
        stopdestroyer()
        WindUI:Notify({
            Title = "PartController",
            Content = "Tpua is Disabled",
            Duration = 5, -- in seconds
        })
    end
})

PartManipTab:Button({
    Title = "Tornado Gui",
    Callback = function() 
        loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/TornadoGuiIg/refs/heads/main/Srrylolitsobfuscatednomorestealing", true))()
        WindUI:Notify({
            Title = "PartController",
            Content = "Loaded TornadoGui",
            Duration = 5, -- in seconds
        })
    end
})


-- partmanip

-- Enhanced Part Magnet with Tornado-Inspired Physics
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- Configuration
local config = {
    BaseRadius = 10,
    MaxRadius = 50,
    Strength = 100,
    UpdateRate = 0.05,
    SimulationRadius = 2000,
    MaxParts = math.huge,
    MaxMass = math.huge,
    ClaimDuration = 30,
    VisualEffects = false,
    Direction = "Pull" -- Added missing Direction parameter
}

-- System Setup
local LocalPlayer = Players.LocalPlayer
local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local magnetEnabled = false
local magnetParts = {}
local claimedParts = {}
local lastUpdate = 0
local connection = nil
local effectModel = Instance.new("Model")
effectModel.Name = "MagnetEffects"
effectModel.Parent = workspace

-- Physics Optimization
local function setSimulationRadius()
    sethiddenproperty(LocalPlayer, "SimulationRadius", config.SimulationRadius)
    sethiddenproperty(LocalPlayer, "MaxSimulationRadius", config.SimulationRadius)
end

-- Part Eligibility Check (Improved from Tornado Script)
local function canManipulatePart(part)
    -- Basic checks
    if not part:IsA("BasePart") then return false end
    if part.Anchored then return false end
    if part:GetMass() > config.MaxMass then return false end
    
    -- Ownership checks
    if claimedParts[part] and claimedParts[part] ~= LocalPlayer then return false end
    
    -- Character checks
    local model = part:FindFirstAncestorOfClass("Model")
    if model and model:FindFirstChildOfClass("Humanoid") then return false end
    
    -- Game protection checks
    if part.Locked then return false end
    if part:GetAttribute("NoManipulate") then return false end
    
    return true
end

-- Claiming System (More robust than before)
local function claimPart(part)
    if not claimedParts[part] then
        claimedParts[part] = {
            Owner = LocalPlayer,
            ClaimTime = tick()
        }
        
        -- Add visual indicator
        if config.VisualEffects then
            local highlight = Instance.new("Highlight")
            highlight.Name = "MagnetClaimHighlight"
            highlight.FillColor = Color3.fromRGB(0, 170, 255)
            highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
            highlight.FillTransparency = 0.7
            highlight.Parent = part
        end
        
        -- Set up auto-release
        delay(config.ClaimDuration, function()
            if claimedParts[part] and claimedParts[part].Owner == LocalPlayer then
                claimedParts[part] = nil
                if part.Parent and part:FindFirstChild("MagnetClaimHighlight") then
                    part.MagnetClaimHighlight:Destroy()
                end
            end
        end)
    end
end

local function releasePart(part)
    if claimedParts[part] and claimedParts[part].Owner == LocalPlayer then
        claimedParts[part] = nil
        if part.Parent and part:FindFirstChild("MagnetClaimHighlight") then
            part.MagnetClaimHighlight:Destroy()
        end
    end
end

-- Force Calculation (Inspired by Tornado physics)
local function calculateMagnetForce(part, rootPosition, direction)
    local distance = (part.Position - rootPosition).Magnitude
    local distanceRatio = math.clamp(1 - (distance/config.MaxRadius), 0, 1)
    
    -- Apply non-linear force curve (like tornado)
    local forceFactor = distanceRatio^2 * config.Strength * 100
    
    -- Add slight upward bias (like tornado lift)
    local forceDirection = direction.Unit + Vector3.new(0, 0.2, 0)
    
    return forceDirection.Unit * forceFactor * part:GetMass()
end

-- Main Magnet Physics Update
local function updateMagnet()
    local currentTime = tick()
    if currentTime - lastUpdate < config.UpdateRate then return end
    lastUpdate = currentTime
    
    setSimulationRadius()
    if not rootPart or not rootPart.Parent then return end
    
    local rootPosition = rootPart.Position
    local direction
    
    -- Find parts in region (more efficient than GetDescendants)
    local parts = workspace:FindPartsInRegion3(
        Region3.new(
            rootPosition - Vector3.new(config.MaxRadius, config.MaxRadius, config.MaxRadius),
            rootPosition + Vector3.new(config.MaxRadius, config.MaxRadius, config.MaxRadius)
        ),
        nil,
        config.MaxParts
    )
    
    for _, part in ipairs(parts) do
        direction = (config.Direction == "Pull") and (rootPosition - part.Position) or (part.Position - rootPosition)
        
        if canManipulatePart(part) then
            claimPart(part)
            
            local force = calculateMagnetForce(part, rootPosition, direction)
            part:ApplyImpulse(force * 0.03) -- More stable than BodyVelocity
            
            -- Add to tracked parts if not already
            if not magnetParts[part] then
                magnetParts[part] = true
                
                -- Clean up when part is removed
                part.AncestryChanged:Connect(function()
                    magnetParts[part] = nil
                    releasePart(part)
                end)
            end
        elseif magnetParts[part] then
            -- Part no longer eligible
            magnetParts[part] = nil
            releasePart(part)
        end
    end
end

-- Cleanup System
local function cleanup()
    for part, _ in pairs(magnetParts) do
        if part and part.Parent then
            releasePart(part)
        end
    end
    magnetParts = {}
    
    if connection then
        connection:Disconnect()
        connection = nil
    end
    
    effectModel:ClearAllChildren()
end

-- Connect cleanup events
LocalPlayer.CharacterRemoving:Connect(cleanup)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", cleanup)

-- UI Controls (similar to your original but enhanced)
-- Note: These assume you have a UI library like WindUI with PartManipTab defined
if PartManipTab then
    PartManipTab:Toggle({
        Title = "Part Magnet",
        Value = false,
        Callback = function(state)
            magnetEnabled = state
            if state then
                character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                rootPart = character:WaitForChild("HumanoidRootPart")
                connection = RunService.Heartbeat:Connect(updateMagnet)
            else
                cleanup()
            end
        end
    })

    PartManipTab:Slider({
        Title = "Magnet Radius",
        Value = {Min = 5, Max = 200, Default = 50},
        Callback = function(value)
            config.MaxRadius = value
        end
    })

    PartManipTab:Slider({
        Title = "Magnet Strength",
        Value = {Min = 1, Max = 1000, Default = 100},
        Callback = function(value)
            config.Strength = value
        end
    })

    PartManipTab:Dropdown({
        Title = "Magnet Direction",
        Values = {"Pull", "Push"},
        Callback = function(value)
            config.Direction = value
        end
    })

    -- Enhanced Part Launcher (using tornado physics principles)
    local launchStrength = 100
    local launchHeight = 50

    PartManipTab:Button({
        Title = "Launch Nearby Parts",
        Callback = function()
            if not rootPart or not rootPart.Parent then return end
            
            local rootPosition = rootPart.Position
            local partsLaunched = 0
            
            local parts = workspace:FindPartsInRegion3(
                Region3.new(
                    rootPosition - Vector3.new(config.MaxRadius, 5, config.MaxRadius),
                    rootPosition + Vector3.new(config.MaxRadius, config.MaxRadius, config.MaxRadius)
                ),
                nil,
                config.MaxParts
            )
            
            for _, part in ipairs(parts) do
                if canManipulatePart(part) then
                    claimPart(part)
                    
                    -- Tornado-inspired launch with better physics
                    local direction = (part.Position - rootPosition).Unit
                    direction = Vector3.new(
                        direction.X * 0.8, 
                        math.clamp(launchHeight/50, 0.3, 1.5),
                        direction.Z * 0.8
                    ).Unit
                    
                    local distanceFactor = 1 - math.clamp((part.Position - rootPosition).Magnitude/config.MaxRadius, 0, 1)
                    local force = direction * launchStrength * part:GetMass() * (0.5 + distanceFactor * 1.5)
                    
                    part:ApplyImpulse(force)
                    partsLaunched += 1
                end
            end
            
            if WindUI then
                WindUI:Notify({
                    Title = "Part Launcher",
                    Content = ("Launched %d parts!"):format(partsLaunched),
                    Duration = 3
                })
            end
        end
    })
end


-- Part Vortex
local vortexEnabled = false
local vortexRadius = 90
local vortexStrength = 3
local vortexDirection = 1 -- 1 for clockwise, -1 for counter-clockwise
local vortexParts = {}

local function updateVortex()
    if not vortexEnabled or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then 
        return 
    end
    
    local rootPos = LocalPlayer.Character.HumanoidRootPart.Position
    
    for _, part in ipairs(workspace:GetDescendants()) do
        if part:IsA("BasePart") and not part.Anchored and not part:IsDescendantOf(LocalPlayer.Character) then
            local distance = (part.Position - rootPos).Magnitude
            if distance <= vortexRadius then
                if not vortexParts[part] then
                    vortexParts[part] = {
                        Velocity = Instance.new("BodyVelocity", part),
                        OriginalProps = {
                            CanCollide = part.CanCollide,
                            CustomPhysicalProperties = part.CustomPhysicalProperties
                        }
                    }
                    vortexParts[part].Velocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                    part.CanCollide = false
                    part.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
                end
                
                -- Calculate tangent direction for circular motion
                local toPart = part.Position - rootPos
                local tangent = Vector3.new(-toPart.Z, 0, toPart.X) * vortexDirection
                tangent = tangent.Unit
                
                -- Add slight inward pull
                local inward = -toPart.Unit * 0.3
                
                -- Calculate force based on distance
                local force = (1 - (distance/vortexRadius)) * vortexStrength * 100
                
                vortexParts[part].Velocity.Velocity = (tangent + inward) * force
            elseif vortexParts[part] then
                -- Restore original properties
                part.CanCollide = vortexParts[part].OriginalProps.CanCollide
                part.CustomPhysicalProperties = vortexParts[part].OriginalProps.CustomPhysicalProperties
                vortexParts[part].Velocity:Destroy()
                vortexParts[part] = nil
            end
        end
    end
end

PartManipTab:Toggle({
    Title = "Part Vortex",
    Value = false,
    Callback = function(state)
        vortexEnabled = state
        if state then
            RunService.Heartbeat:Connect(updateVortex)
        else
            -- Clean up
            for part, data in pairs(vortexParts) do
                if part and part.Parent then
                    part.CanCollide = data.OriginalProps.CanCollide
                    part.CustomPhysicalProperties = data.OriginalProps.CustomPhysicalProperties
                    data.Velocity:Destroy()
                end
            end
            vortexParts = {}
        end
    end
})

PartManipTab:Dropdown({
    Title = "Vortex Direction",
    Values = {"Clockwise", "Counter-Clockwise"},
    Callback = function(value)
        vortexDirection = (value == "Clockwise") and 1 or -1
    end
})

WindUI:Notify({
    Title = "PartController",
    Content = "Loaded",
    Duration = 5, -- in seconds
})
